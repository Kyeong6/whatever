# 업무내용

- 개발 수정사항 반영하여 로직 변경 진행

## 8/12

### 워크플로

**변경사항**

지난 주에 정리한 변경 사항은 다음과 같다.

알림용 텍스트파일 같은 경우 작업자(operator)에게 이상치 알림을 주기 때문에 이상치 알림 전용 텍스트파일이라고 할 수 있고, 서버용 텍스트파일 같은 경우 최종적으로 모바일 어플리케이션을 구축하기 때문에 10분마다 업데이트하기 위한 전달 프로토콜이다.

- Mini PC에서 이상치와 예측에 관한 기능 수행 후 알림용(1 min) / 서버용(10 min) txt 파일 구성
- 작업 주기 정리
    - 1 min : 알림용
        - 센서 데이터 수집 → 실측값 테이블 적재 → 이상치 검출 → 검출 결과 DB 적재 → 알림 / 서버용 txt 파일 구성(data/sensor/alert.txt, data/sensor/server.txt)
        - 서버 실행 후 1년이 지날 경우 데이터 삭제(해당 시간 - 365 day)
    - 10 min : 서버용
        - 1 min 작업에서 서버용 텍스트 파일을 분마다 구성하고 있고, 만약 1 hr 작업이 수행된다면 예측 속성에 값 넣기(정각이 아닌 경우는 예측 속성 값 NULL)
    - 1 hr : 예측용
        - 실측값 테이블 조회(60 rows) → csv 변환 수행(input) → LSTM 예측 수행 → 예측값 DB 적재 → 예측값 서버용 텍스트파일 구성
    - 3 mon : 이상치 기준 설정
        - 실측값 및 야간 유량 테이블 조회 → 이상치 기준 설정 및 변경
    - 1 hr : 학습용
        - 실측값 테이블 조회(1 yr) → LSTM 학습 수행(데이터 전처리 → 학습) → 모델 파일, 스케일러 파일 저장(output/Learning_lstm/flow_rate, output/Learning_lstm/pressure)

**최종 아키텍처 및 워크플로 도식화**

| <img src="https://github.com/user-attachments/assets/99ef69a0-2717-428d-bf80-1d26ef8980af" alt="lstm-pipeline" width="500" /> | <img src="https://github.com/user-attachments/assets/47edcf8f-db80-4af9-bb2a-9e999ec0f971" alt="workflow" width="500" /> | 
| ------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------ | 
| <div style="text-align: center;">LSTM pipeline &nbsp;&nbsp;&nbsp;</div>                                                         | <div style="text-align: center;">Workflow &nbsp;&nbsp;&nbsp;</div>                                                         |

### Pyserial을 이용한 센서데이터 얻기

Serial 통신을 통해 센서 데이터를 받는데 기존에는 `while True:` 를 사용하여 반복적으로 체크를 하였다. 

`while True:` 방식 같은 경우는 **폴링 방식**으로 데이터를 놓치지 않는다는 장점이 있지만 그만큼 비용에 관한 trade off가 존재한다. 따라서 **이벤트 기반 방식**을 도입 하였고 폴링 방식과 이벤트 기반 방식의 CPU 사용량, 시스템 효율성을 비교하고 성능 차이를 정량적으로 파악했다. 

**CPU 사용량**

- 폴링 방식
    - 데이터가 도착하지 않아도 반복적으로 체크하여 CPU가 불필요하게 계속 일을 하게되며, 사용률이 높다.
    - CPU 사용량이 높은만큼 전력 소모가 증가한다.
        - 현재 프로젝트의 최종적인 목표는 임베디드 시스템에서의 구동이기 때문에 전력 소모가 크다면 문제가 생긴다.
- 이벤트 기반 방식
    - 데이터가 도착할 때만 CPU가 작업을 수행하므로 이벤트가 발생하지 않았을 경우는 유휴(idle)상태이므로 CPU 사용량이 크게 줄어든다.
    - CPU 사용량이 적은만큼 전력 소모도 줄어든다.

**시스템 효율성**

- 폴링 방식
    - 필요 없는 작업을 계속 수행하기 때문에 전체 시스템 효율성 저하시킨다.
    - 높은 빈도로 폴링하는 경우 쓰레드가 많이 필요할 수 있어 시스템 리소스를 더 많이 차지한다.
- 이벤트 기반 방식
    - 데이터가 도착할 때만 작업을 수행하므로 시스템 효율성이 높아진다.
        - 다른 작업을 처리할 수 있는 리소스가 많아져 신속하게 반응할 수 있다.
    - 일반적으로 쓰레드 수가 적게 필요하여 이로 인해 메모리 사용량 줄어든다.

**정량적 비교(예시)**

CPU 사용량과 전력 소모를 비교하기 위해 가정된 예를 들면 다음과 같다.

- 가정: CPU가 `while True:` 방식으로 1분마다 데이터를 체크한다고 가정하고, 이벤트 기반 접근에서는 유휴 상태에 있다가 데이터가 도착하면 처리한다고 가정
- 시스템 구성: CPU가 2GHz에서 작동하고, 폴링 방식에서 50% 사용률, 이벤트 기반에서 5% 사용률이 예상된다고 가정

- 폴링 방식
    - CPU 사용 시간: 60초 동안 50% 사용
        - `60초 * 50%` = 30초 동안 CPU가 사용됩니다.
    - 전력 소모: CPU가 완전 가동 시 10W의 전력을 소모한다고 가정
        - `30초 * 10W` = 5Wh

- 이벤트 방식
    - CPU 사용 시간: 60초 동안 5% 사용
        - `60초 * 5%` = 3초 동안 CPU가 사용됩니다.
    - 전력 소모: CPU가 완전 가동 시 10W의 전력을 소모한다고 가정
        - `3초 * 10W` = 0.5Wh
- 결론
    - 비용 차이: 폴링 방식은 이벤트 기반 방식에 비해 약 10배 더 많은 CPU 사용 시간과 전력 소모 가진다.
    - 효율성: 이벤트 기반 시스템은 리소스를 덜 사용하므로 효율적

**추후 진행할 정량적 비교**

1. 시스템의 CPU 사용량 측정
    - CPU 사용률: 이벤트 기반 접근과 폴링 접근 방식 각각에서 CPU 사용률을 정확하게 측정
        - 시스템 모니터링 도구(예: top, htop, Windows Performance Monitor)를 사용해 특정 시간 동안의 평균 CPU 사용률을 수집
    - 작업 부하: 두 접근 방식에서 동일한 작업 부하를 처리하도록 보장하여, 비교할 때 공정성을 유지합니다.
2. 전력 소모 측정
    - 전력 소모량: 각 접근 방식에서 소비되는 전력량을 측정
        - powerstat(Linux), powercfg(Windows), 또는 실제 전력 측정 장비를 사용하여 측정
    - 전력 소모 모델링: 시스템의 전력 소모를 모델링하여, 폴링과 이벤트 기반 접근의 전력 소모 예측
3. 응답 시간 및 처리 지연 측정
    - 응답 시간: 데이터를 수신했을 때 이벤트 기반 시스템과 폴링 시스템이 데이터를 처리하는 데 걸리는 시간을 측정
    - 처리 지연: 특히 폴링 방식에서는 데이터가 도착한 후 다음 폴링 주기까지 지연이 발생, 이 지연 시간을 측정하여 비교
4. 메모리 사용량 측정
    - 메모리 사용량: 각 접근 방식이 사용하는 메모리 양을 측정
        - free -m, vmstat, 또는 Windows Task Manager와 같은 도구를 사용해 측정
    - 스레드 수 및 메모리 오버헤드: 각 방식이 사용하는 스레드 수와 그에 따른 메모리 오버헤드 측정